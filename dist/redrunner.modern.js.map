{"version":3,"file":"redrunner.modern.js","sources":["../src/utils.js","../src/redrunner.js","../src/view.js"],"sourcesContent":["const doc = document;\n\n/**\n * Some utility functions\n */\nexport const und = x => x === undefined\nexport const isStr = x => typeof x === 'string'\n\n/**\n * Creates and mounts a view onto an element.\n *\n * @param {unsure} elementOrId Either a string representing an id, or an\n *     element.\n * @param {class} cls The class of View to create\n * @param {object} props The props to pass to the view (optional)\n * @param {object} parent The parent view (optional)\n * @param {int} seq The sequence (optional)\n */\nexport function mount(elementOrId, cls, props, parent, seq) {\n  let view = createView(cls, props, parent, seq)\n  let target = isStr(elementOrId) ? doc.getElementById(elementOrId.slice(1)) : elementOrId\n  target.parentNode.replaceChild(view.root.e, target)\n  return view\n}\n\n/**\n * Creates a wrapper from an HTML string.\n */\nexport function wrap(html) {\n  let throwAway = document.createElement('template')\n  throwAway.innerHTML = html\n  return new Wrapper(throwAway.content.firstChild)\n}\n\n/**\n * Creates a wrapper of type tag and sets inner.\n * TODO: allow class in tag?\n */\nexport function h(tag, inner) {\n  return new Wrapper(document.createElement(tag)).inner(inner)\n}\n\n/**\n * Creates a view, builds its DOM, and updates it.\n *\n * @param {class} cls The class of View to create\n * @param {object} parent The parent view (optional)\n * @param {object} props The props to pass to the view (optional)\n * @param {int} seq The sequence (optional)\n */\nexport function createView(cls, props, parent, seq) {\n  let view = new cls(parent, props, seq)\n  view.__bv(view, wrap)\n  view.init()\n  view.update()\n  return view\n}\n\n/**\n * An object which caches and returns views of a same type.\n *\n@cls -- any valid subclass of View\n@cacheBy -- either:\n    <undefined> in which case the sequence is used as key*\n    A string used to lookup a property on the item. Can be dotted. e.g. 'user.id'\n    A function called with (props, seq) which must return a key\n*/\n\nexport class ViewCache {\n  /**\n   * @param {class} cls The class of View to create\n   * @param {object} parent The parent view (optional)\n   */\n  constructor(cls, view, keyFn) {\n    let defaultKeyFn = (props, seq) => seq\n    this.view = view\n    this.cls = cls\n    this.cache = {}\n    this.keyFn = keyFn || defaultKeyFn\n    this._seq = 0\n  }\n  reset() {\n    this._seq = 0\n  }\n  get(props) {\n    /*\n    Gets a view, potentially from cache\n    */\n    let view, key = this.keyFn(props, this._seq)\n    if (this.cache.hasOwnProperty(key)) {\n      view = this.cache[key]\n    } else {\n      view = createView(this.cls, props, this.view, this._seq)\n      this.cache[key] = view\n    }\n    view.update(props)\n    this._seq += 1\n    return view\n  }\n}\n\nexport class Wrapper {\n  constructor(element, view) {\n    this.e = element\n    this._c = undefined // The viewCache, if any\n    this._n = undefined //  \n    this.view = view\n  }\n  \n  // Methods which potentially change the containing view's nested views \n  append(item) {\n    return this._append(item)\n  }\n  _append(item) {\n    return this.e.appendChild(item.e)\n  }\n  child(item) {\n    this.clear()\n    return this._append(item)\n  }\n  replace(el) {\n    this.e.parentNode.replaceChild(el, this.e)\n  }\n  clear() {\n    if (this._n) {\n      this._n.length = 0\n    }\n    this.e.innerHTML = ''\n    this.e.textContent = ''\n    this.e.value = ''\n    return this\n  }\n  html(html) {\n    this.e.innerHTML = html\n    return this\n  }\n  inner(items) {\n    /*\n     * Use this for adding standard lists of items. Use items() is you used use()\n     */\n    if (!Array.isArray(items)) {\n      return this.child(items)\n    }\n    this._prepRepeat()\n    for (var i=0, il=items.length; i<il; i++) {\n      this._append(items[i])\n    }\n    return this._done()\n  }\n  items(items) {\n    this._prepRepeat()\n    let view\n    for (var i=0, il=items.length; i<il; i++) {\n      view = this._c.get(items[i])\n      this._nest(view)\n      this.e.appendChild(view.root.e)\n    }\n    return this._done()\n  }\n  _nest(view) {\n    //TODO: the idea of this it to keep track of nested views. Check it works...\n    if (!this._n) {\n      this._n = this.view.__nv\n    }\n    this._n.push(view)\n  }\n  _prepRepeat() {\n    this.visible(false)\n    this.clear()\n  }\n  _done() {\n    this.visible(true)\n    return this\n  }\n  use(cls) {\n    this._c = new ViewCache(cls, this)\n    return this\n  }\n  watch(desc, callback) {\n    /*\n     *   Watch a value and do something if it has changed.\n     * \n     *   This method has two forms.\n     * \n     *   If desc does not contain \":\" then the callback is simply called if the value \n     *   changes (during the view's update() call)\n     *\n     *   The callback parameters are (newVal, oldVal, wrapper) \n     *   E.g.\n     *\n     *      h('div').watch('clickCount', (n,o,w) => w.text(n))\n     *\n     *   If the desc contains \":\" (e.g. \"text:clickCount\") then we assume what is to \n     *   the left of : to be a method of the wrapper to call if the value has changed.\n     *   E.g.\n     *\n     *       h('div').watch('text:clickCount')  // equates to wrapper.text(newValue)\n     *   \n     *   In this form, a callback may be provided to transform the value before it is\n     *   used. Its parameters are (newVal, oldVal) \n     *   \n     *    E.g.\n     *\n     *       h('div').watch('text:clickCount', (n,o) => `Click count is ${n}`)\n     *   \n     */\n    let path, func, chunks = desc.split(':')\n    if (chunks.length === 1) {\n      path = chunks[0]\n      func = (n,o) => callback(n,o,this)\n    } else {\n      let method = chunks[0]\n      path = chunks[1]\n      func = und(callback) ? n => this[method](n) : (n,o) => this[method](callback(n,o,this)) \n    }\n    this.view.watch(path, func)\n    return this\n  }\n\n  // These methods are mostly simple DOM wrappers\n\n  get Value() {\n    /* Returns the value of the element */\n    return this.e.value\n  }\n  css(style) {\n    this.e.className = style\n    return this\n  }\n  cssAdd(style) {\n    this.e.classList.add(style)\n    return this\n  }\n  cssAddTrans(style) {\n    return this.transition(_ => this.e.classList.add(style))\n  }\n  cssRemove(style) {\n    this.e.classList.remove(style)\n    return this\n  }\n  cssRemoveTrans(style) {\n    return this.transition(_ => this.e.classList.remove(style))\n  }\n  cssToggle(style) {\n    this.e.classList.toggle(style)\n    return this\n  }\n  att(name, value) {\n    this.e.setAttribute(name, value)\n    return this\n  }\n  atts(atts) {\n    for (let name in atts) {\n      this.att(name, atts[name])\n    }\n    return this\n  }\n  checked(value) {\n    this.e.checked = value\n    return this\n  }\n  href(value) {\n    return this.att('href', value)\n  }\n  id(value) {\n    return this.att('id', value)\n  }\n  src(value) {\n    return this.att('src', value)\n  }\n  value(value) {\n    return this.att('value', value)\n  }\n  text(value) {\n    this.e.textContent = value\n    return this\n  }\n  on(event, callback) {\n    this.e.addEventListener(event, e => callback(e, this))\n    return this\n  }\n  style(name, value) {\n    this.e.style[name] = value\n    return this\n  }\n  transition(fn) {\n    return new Promise(resolve => {\n      fn()\n      let transitionEnded = e => {\n        this.e.removeEventListener('transitionend', transitionEnded)\n        resolve()\n      }\n    this.e.addEventListener('transitionend', transitionEnded)\n    })\n  }\n  visible(visible) {\n    return this.style('visibility', visible? 'visible' : 'hidden')\n  }\n}\n","import {View} from './view'\nimport {mount} from './utils'\n\nmodule.exports = {View, mount}","import {\n  createView,\n  und, \n  wrap, // Keep this, its used by babel\n  Wrapper\n} from './utils'\n\n/*\n * Public members:\n *\n *  nest    -- create a nested view\n *  debug   -- prints out debug info\n *  dom     -- an object containing all the saved wrappers\n *  emit    -- emit an event to be handled by a parent views\n *  handle  -- register a function to handle an event emitted by a nested view\n *  init    -- override to set initial state \n *  parent  -- the parent view\n *  props   -- the props passed to the view\n *  root    -- the root wrapper (should root even be a wrapper?)\n *  seq     -- the sequence\n *  update  -- method which gets called when a view is updated\n *  \n * Private members (for internal use) start with __ and are listed here:\n *\n *  __bv (BuildView)  -- is built by babel\n *  __ia (IsAttached)\n *  __gw (GetWrapper) -- returns a wrapper at a specific path\n *  __nv (NestedViews)\n *  __ov (OldValues)\n *  __rn (ReplaceNode)\n *  __un (Update Nested Views)\n *  __uw (Update Watches)\n *  __wc (Watcher Callbacks)\n *\n */\nexport class View {\n  constructor(parent, props, seq) {\n    let s = this\n    s.parent = parent       // The parent view\n    s.props = props         // The props passed to the view. May be changed\n    s.seq = seq             // The sequence - only for nested views\n    // Internal state objects\n    s.__nv = []         // Array of arrays of nested views\n\n    // These relate to watchers\n    s.__ov = {}       // The old values for watches to compare against  \n\n    // These will be set by __bv()\n    s.root = null           // the root wrapper, will be set by __bv\n    s.dom = null            // the named wrappers, will be set by __bv\n  }\n\n  /* This field gets transformed by the babel plugin.\n   * Providing a default here so that child classes get processed.\n   */\n  __html__ = '<div/>'\n\n  init() {\n    // Gets called once\n  }\n  update(props) {\n    /*  \n     *   The external call to update the view. \n     *   @props -- new props, else it keeps its old (which is fine)\n     */\n    if (!und(props)) {\n      this.props = props\n    }\n    this.__uw()\n    this.__un()\n  }\n  debug() {\n    c.log(this.__bv.toString())\n    let lines = []\n    lines.push('__wc: {')\n    for (let [name, callbacks] of Object.entries(this.__wc)) {\n      lines.push(`  \"${name}\": [`)\n      callbacks.forEach(e => lines.push('  ' + e.toString()))\n      lines.push('  ]')\n    }\n    lines.push('}')\n    c.log(lines.join('\\n'))\n  }\n  nest(cls, props, seq) {\n    /*\n     * Builds a nested view of the specified class. Its up to you how you attach it.\n     * No caching is used. Use a cache object returned by this.cache() if you need caching.\n     */\n    let child = createView(cls, props, this, seq)\n    this.__nv.push(child)\n    return child\n  }\n  emit(name, args) {\n    let target = this\n    while (!und(target)) {\n      let handlers = target._handlers_\n      if (name in handlers) {\n        return handlers[name].apply(target, args)\n      }\n      target = target.parent\n    }\n  }\n  old(name) {\n    return this.__ov[name]\n  }\n  watch(path, callback) {\n    /*\n    Watch a property and call the callback during update if it has changed.\n\n    @path -- A dotted path to the value\n\n      e.g. 'user.id'\n    \n    @callback -- a function to be called with (newValue, oldValue)\n    \n      e.g. (n,o) => alert(`Value changed from ${o} to ${n}`)\n\n    */\n    if (!this.__wc.hasOwnProperty(path)) {\n      this.__wc[path] = []\n    }\n    this.__wc[path].push(callback)\n    return this // Keep this because people may use it like on the wrapper.\n  }\n  __gw(path) {\n    /*\n    Returns a wrapper around element at path, where path is an array of indices.\n    This is used by the babel plugin.\n    */\n    let el = path.reduce((accumulator, index) => accumulator.childNodes[index], this.root.e)\n    return new Wrapper(el, this)\n  }\n  __un() {\n    this.__nv.forEach(child => {\n      if (child.__ia()) {\n         child.update()\n      }\n    })\n  }\n  __uw() {\n    /*\n     * Iterates through watches. If the value has changed, call callback.\n     */\n    let path, newValue, previousValue, callbacks\n    for (path in this.__wc) {\n      newValue = this.__wq[path].apply(this)\n      previousValue = this.__ov[path]\n      if (path === '' || previousValue !== newValue) {\n        callbacks = this.__wc[path]\n        for (var i=0, il=callbacks.length; i<il; i++) {\n          callbacks[i].apply(this, [newValue, previousValue])\n        }\n      }\n      this.__ov[path] = newValue\n    }\n  }\n  __rn(path, view) {\n    this.__gw(path).replace(view.root.e)\n  }\n  __ia() {\n    let el = this\n    // TODO: loop until parent\n    // let element = \n    // while (element != document && element.parentNode) {\n    //   /* jump to the parent element */\n    //   element = element.parentNode;\n    // }\n    return el.root.e.parentNode\n  }\n\n  /* Currently unused, but we may use it in future strategy\n   */\n  // _cloneNode_() {\n  //   let ct = this._ct_\n  //   if (!ct._template_) {\n  //     let throwAway = document.createElement('template')\n  //     // let tidy = raw.replace(/\\n/g, \"\")\n  //     //   .replace(/[\\t ]+\\</g, \"<\")\n  //     //   .replace(/\\>[\\t ]+\\</g, \"><\")\n  //     //   .replace(/\\>[\\t ]+$/g, \">\")\n  //     throwAway.innerHTML = ct.html.trim()\n  //     ct._template_ = throwAway.content.firstChild\n  //   }\n  //   return ct._template_.cloneNode(true)\n  // }\n}"],"names":["doc","document","und","x","undefined","wrap","html","throwAway","createElement","innerHTML","Wrapper","content","firstChild","createView","cls","props","parent","seq","view","__bv","init","update","ViewCache","constructor","keyFn","this","cache","_seq","reset","get","key","hasOwnProperty","element","e","_c","_n","append","item","_append","appendChild","child","clear","replace","el","parentNode","replaceChild","length","textContent","value","inner","items","Array","isArray","_prepRepeat","i","il","_done","_nest","root","__nv","push","visible","use","watch","desc","callback","path","func","chunks","split","n","o","method","Value","css","style","className","cssAdd","classList","add","cssAddTrans","transition","_","cssRemove","remove","cssRemoveTrans","cssToggle","toggle","att","name","setAttribute","atts","checked","href","id","src","text","on","event","addEventListener","fn","Promise","resolve","transitionEnded","removeEventListener","exports","View","__html__","s","__ov","dom","__uw","__un","debug","c","log","toString","lines","callbacks","Object","entries","__wc","forEach","join","nest","emit","args","target","handlers","_handlers_","apply","old","__gw","reduce","accumulator","index","childNodes","__ia","newValue","previousValue","__wq","__rn","mount","elementOrId","getElementById","slice"],"mappings":"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"}