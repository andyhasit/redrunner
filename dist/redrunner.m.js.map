{"version":3,"file":"redrunner.m.js","sources":["../src/utils.js","../src/view.js","../src/router.js","../src/redrunner.js","../src/store.js"],"sourcesContent":["const doc = document;\n\n/**\n * Some utility functions\n */\nexport const und = x => x === undefined\nexport const isStr = x => typeof x === 'string'\n\n/**\n * Creates and mounts a view onto an element.\n *\n * @param {unsure} elementOrId Either a string representing an id, or an\n *     element.\n * @param {class} cls The class of View to create\n * @param {object} props The props to pass to the view (optional)\n * @param {object} parent The parent view (optional)\n * @param {int} seq The sequence (optional)\n */\nexport function mount(elementOrId, cls, props, parent, seq) {\n  let view = createView(cls, props, parent, seq)\n  let target = isStr(elementOrId) ? doc.getElementById(elementOrId.slice(1)) : elementOrId\n  target.parentNode.replaceChild(view.root.e, target)\n  return view\n}\n\n/**\n * Creates a wrapper from an HTML string.\n */\nexport function wrap(html) {\n  let throwAway = document.createElement('template')\n  throwAway.innerHTML = html\n  return new Wrapper(throwAway.content.firstChild)\n}\n\n/**\n * Creates a wrapper of type tag and sets inner.\n * TODO: allow class in tag?\n */\nexport function h(tag, inner) {\n  return new Wrapper(document.createElement(tag)).inner(inner)\n}\n\n/**\n * Creates a view, builds its DOM, and updates it.\n *\n * @param {class} cls The class of View to create\n * @param {object} parent The parent view (optional)\n * @param {object} props The props to pass to the view (optional)\n * @param {int} seq The sequence (optional)\n */\nexport function createView(cls, props, parent, seq) {\n  let view = new cls(parent, props, seq)\n  view.__bv(view, wrap)\n  view.init()\n  view.update()\n  return view\n}\n\n/**\n * An object which caches and returns views of a same type.\n *\n@cls -- any valid subclass of View\n@cacheBy -- either:\n    <undefined> in which case the sequence is used as key*\n    A string used to lookup a property on the item. Can be dotted. e.g. 'user.id'\n    A function called with (props, seq) which must return a key\n*/\n\nexport class ViewCache {\n  /**\n   * @param {class} cls The class of View to create\n   * @param {object} parent The parent view (optional)\n   */\n  constructor(cls, view, keyFn) {\n    let defaultKeyFn = (props, seq) => seq\n    this.view = view\n    this.cls = cls\n    this.cache = {}\n    this.keyFn = keyFn || defaultKeyFn\n    this._seq = 0\n  }\n  reset() {\n    this._seq = 0\n  }\n  get(props) {\n    /*\n    Gets a view, potentially from cache\n    */\n    let view, key = this.keyFn(props, this._seq)\n    if (this.cache.hasOwnProperty(key)) {\n      view = this.cache[key]\n    } else {\n      view = createView(this.cls, props, this.view, this._seq)\n      this.cache[key] = view\n    }\n    view.update(props)\n    this._seq += 1\n    return view\n  }\n}\n\nexport class Wrapper {\n  constructor(element, view) {\n    this.e = element\n    this._c = undefined // The viewCache, if any\n    this._n = undefined //  \n    this.view = view\n  }\n  \n  // Methods which potentially change the containing view's nested views \n  append(item) {\n    return this._append(item)\n  }\n  _append(item) {\n    return this.e.appendChild(item.e)\n  }\n  child(item) {\n    this.clear()\n    return this._append(item)\n  }\n  replace(el) {\n    this.e.parentNode.replaceChild(el, this.e)\n  }\n  clear() {\n    if (this._n) {\n      this._n.length = 0\n    }\n    this.e.innerHTML = ''\n    this.e.textContent = ''\n    this.e.value = ''\n    return this\n  }\n  html(html) {\n    this.e.innerHTML = html\n    return this\n  }\n  inner(items) {\n    /*\n     * Use this for adding standard lists of items. Use items() is you used use()\n     */\n    if (!Array.isArray(items)) {\n      return this.child(items)\n    }\n    this._prepRepeat()\n    for (var i=0, il=items.length; i<il; i++) {\n      this._append(items[i])\n    }\n    return this._done()\n  }\n  items(items) {\n    this._prepRepeat()\n    let view\n    for (var i=0, il=items.length; i<il; i++) {\n      view = this._c.get(items[i])\n      this._nest(view)\n      this.e.appendChild(view.root.e)\n    }\n    return this._done()\n  }\n  _nest(view) {\n    //TODO: the idea of this it to keep track of nested views. Check it works...\n    if (!this._n) {\n      this._n = this.view.__nv\n    }\n    this._n.push(view)\n  }\n  _prepRepeat() {\n    this.visible(false)\n    this.clear()\n  }\n  _done() {\n    this.visible(true)\n    return this\n  }\n  use(cls) {\n    this._c = new ViewCache(cls, this)\n    return this\n  }\n  watch(desc, callback) {\n    /*\n     *   Watch a value and do something if it has changed.\n     * \n     *   This method has two forms.\n     * \n     *   If desc does not contain \":\" then the callback is simply called if the value \n     *   changes (during the view's update() call)\n     *\n     *   The callback parameters are (newVal, oldVal, wrapper) \n     *   E.g.\n     *\n     *      h('div').watch('clickCount', (n,o,w) => w.text(n))\n     *\n     *   If the desc contains \":\" (e.g. \"text:clickCount\") then we assume what is to \n     *   the left of : to be a method of the wrapper to call if the value has changed.\n     *   E.g.\n     *\n     *       h('div').watch('text:clickCount')  // equates to wrapper.text(newValue)\n     *   \n     *   In this form, a callback may be provided to transform the value before it is\n     *   used. Its parameters are (newVal, oldVal) \n     *   \n     *    E.g.\n     *\n     *       h('div').watch('text:clickCount', (n,o) => `Click count is ${n}`)\n     *   \n     */\n    let path, func, chunks = desc.split(':')\n    if (chunks.length === 1) {\n      path = chunks[0]\n      func = (n,o) => callback(n,o,this)\n    } else {\n      let method = chunks[0]\n      path = chunks[1]\n      func = und(callback) ? n => this[method](n) : (n,o) => this[method](callback(n,o,this)) \n    }\n    this.view.watch(path, func)\n    return this\n  }\n\n  // These methods are mostly simple DOM wrappers\n\n  get Value() {\n    /* Returns the value of the element */\n    return this.e.value\n  }\n  css(style) {\n    this.e.className = style\n    return this\n  }\n  cssAdd(style) {\n    this.e.classList.add(style)\n    return this\n  }\n  cssAddTrans(style) {\n    return this.transition(_ => this.e.classList.add(style))\n  }\n  cssRemove(style) {\n    this.e.classList.remove(style)\n    return this\n  }\n  cssRemoveTrans(style) {\n    return this.transition(_ => this.e.classList.remove(style))\n  }\n  cssToggle(style) {\n    this.e.classList.toggle(style)\n    return this\n  }\n  att(name, value) {\n    this.e.setAttribute(name, value)\n    return this\n  }\n  atts(atts) {\n    for (let name in atts) {\n      this.att(name, atts[name])\n    }\n    return this\n  }\n  checked(value) {\n    this.e.checked = value\n    return this\n  }\n  href(value) {\n    return this.att('href', value)\n  }\n  id(value) {\n    return this.att('id', value)\n  }\n  src(value) {\n    return this.att('src', value)\n  }\n  value(value) {\n    return this.att('value', value)\n  }\n  text(value) {\n    this.e.textContent = value\n    return this\n  }\n  on(event, callback) {\n    this.e.addEventListener(event, e => callback(e, this))\n    return this\n  }\n  style(name, value) {\n    this.e.style[name] = value\n    return this\n  }\n  transition(fn) {\n    return new Promise(resolve => {\n      fn()\n      let transitionEnded = e => {\n        this.e.removeEventListener('transitionend', transitionEnded)\n        resolve()\n      }\n    this.e.addEventListener('transitionend', transitionEnded)\n    })\n  }\n  visible(visible) {\n    return this.style('visibility', visible? 'visible' : 'hidden')\n  }\n}\n","import {\n  createView,\n  und, \n  wrap, // Keep this, its used by babel\n  Wrapper\n} from './utils'\n\n/*\n * Public members:\n *\n *  nest    -- create a nested view\n *  debug   -- prints out debug info\n *  dom     -- an object containing all the saved wrappers\n *  emit    -- emit an event to be handled by a parent views\n *  handle  -- register a function to handle an event emitted by a nested view\n *  init    -- override to set initial state \n *  parent  -- the parent view\n *  props   -- the props passed to the view\n *  root    -- the root wrapper (should root even be a wrapper?)\n *  seq     -- the sequence\n *  update  -- method which gets called when a view is updated\n *  \n * Private members (for internal use) start with __ and are listed here:\n *\n *  __bv (BuildView)  -- is built by babel\n *  __ia (IsAttached)\n *  __gw (GetWrapper) -- returns a wrapper at a specific path\n *  __nv (NestedViews)\n *  __ov (OldValues)\n *  __rn (ReplaceNode)\n *  __un (Update Nested Views)\n *  __uw (Update Watches)\n *  __wc (Watcher Callbacks)\n *\n */\nexport class View {\n  constructor(parent, props, seq) {\n    let s = this\n    s.parent = parent       // The parent view\n    s.props = props         // The props passed to the view. May be changed\n    s.seq = seq             // The sequence - only for nested views\n    // Internal state objects\n    s.__nv = []         // Array of arrays of nested views\n\n    // These relate to watchers\n    s.__ov = {}       // The old values for watches to compare against  \n\n    // These will be set by __bv()\n    s.root = null           // the root wrapper, will be set by __bv\n    s.dom = null            // the named wrappers, will be set by __bv\n  }\n\n  /* This field gets transformed by the babel plugin.\n   * Providing a default here so that child classes get processed.\n   */\n  __html__ = '<div/>'\n\n  init() {\n    // Gets called once\n  }\n  update(props) {\n    /*  \n     *   The external call to update the view. \n     *   @props -- new props, else it keeps its old (which is fine)\n     */\n    if (!und(props)) {\n      this.props = props\n    }\n    this.__uw()\n    this.__un()\n  }\n  debug() {\n    c.log(this.__bv.toString())\n    let lines = []\n    lines.push('__wc: {')\n    for (let [name, callbacks] of Object.entries(this.__wc)) {\n      lines.push(`  \"${name}\": [`)\n      callbacks.forEach(e => lines.push('  ' + e.toString()))\n      lines.push('  ]')\n    }\n    lines.push('}')\n    c.log(lines.join('\\n'))\n  }\n  nest(cls, props, seq) {\n    /*\n     * Builds a nested view of the specified class. Its up to you how you attach it.\n     * No caching is used. Use a cache object returned by this.cache() if you need caching.\n     */\n    let child = createView(cls, props, this, seq)\n    this.__nv.push(child)\n    return child\n  }\n  emit(name, args) {\n    let target = this\n    while (!und(target)) {\n      let handlers = target._handlers_\n      if (name in handlers) {\n        return handlers[name].apply(target, args)\n      }\n      target = target.parent\n    }\n  }\n  old(name) {\n    return this.__ov[name]\n  }\n  watch(path, callback) {\n    /*\n    Watch a property and call the callback during update if it has changed.\n\n    @path -- A dotted path to the value\n\n      e.g. 'user.id'\n    \n    @callback -- a function to be called with (newValue, oldValue)\n    \n      e.g. (n,o) => alert(`Value changed from ${o} to ${n}`)\n\n    */\n    if (!this.__wc.hasOwnProperty(path)) {\n      this.__wc[path] = []\n    }\n    this.__wc[path].push(callback)\n    return this // Keep this because people may use it like on the wrapper.\n  }\n  __gw(path) {\n    /*\n    Returns a wrapper around element at path, where path is an array of indices.\n    This is used by the babel plugin.\n    */\n    let el = path.reduce((accumulator, index) => accumulator.childNodes[index], this.root.e)\n    return new Wrapper(el, this)\n  }\n  __un() {\n    this.__nv.forEach(child => {\n      if (child.__ia()) {\n         child.update()\n      }\n    })\n  }\n  __uw() {\n    /*\n     * Iterates through watches. If the value has changed, call callback.\n     */\n    let path, newValue, previousValue, callbacks\n    for (path in this.__wc) {\n      newValue = this.__wq[path].apply(this)\n      previousValue = this.__ov[path]\n      if (path === '' || previousValue !== newValue) {\n        callbacks = this.__wc[path]\n        for (var i=0, il=callbacks.length; i<il; i++) {\n          callbacks[i].apply(this, [newValue, previousValue])\n        }\n      }\n      this.__ov[path] = newValue\n    }\n  }\n  __rn(path, view) {\n    this.__gw(path).replace(view.root.e)\n  }\n  __ia() {\n    let el = this\n    // TODO: loop until parent\n    // let element = \n    // while (element != document && element.parentNode) {\n    //   /* jump to the parent element */\n    //   element = element.parentNode;\n    // }\n    return el.root.e.parentNode\n  }\n\n  /* Currently unused, but we may use it in future strategy\n   */\n  // _cloneNode_() {\n  //   let ct = this._ct_\n  //   if (!ct._template_) {\n  //     let throwAway = document.createElement('template')\n  //     // let tidy = raw.replace(/\\n/g, \"\")\n  //     //   .replace(/[\\t ]+\\</g, \"<\")\n  //     //   .replace(/\\>[\\t ]+\\</g, \"><\")\n  //     //   .replace(/\\>[\\t ]+$/g, \">\")\n  //     throwAway.innerHTML = ct.html.trim()\n  //     ct._template_ = throwAway.content.firstChild\n  //   }\n  //   return ct._template_.cloneNode(true)\n  // }\n}","import {View} from './view'\nimport {ViewCache, isStr} from './utils'\n\n/*\n * The defaultKeyFn for a route's ViewCache.\n * It returns 1, which causes the same view to be reused each time, which is most likely \n * what we want, but means the view should must be stateless.\n */\nconst defaultKeyFn = _ => 1\n\n/*\n * Router - an object responsible for managing routes\n\n -- how do we cache and update views?\n\nWhen a route is first activated, the view gets instantiated and we call update()\nWhen a route is reactivated, there are options:\n  - build a completely new view\n  - retrieve a cached view based on args\n  - always reuse the same view\n\nTodo:\n  change route to accept a cache - else it creates its own\n\n  this.cache()\n\nhttps://blog.pshrmn.com/entry/how-single-page-applications-work/\n\n\nparams vs vars\n*/\n\n\n/* RouterView\n * A view which responds to changes in the hash url.\n * Arg 'data' must be an object like {routes, resources}\n * \n * @data.routes: an array of objects which will get passed as arg 'config' to new Route()\n * @data.resources: an object representing load-once resources as name:function\n *   the function will be called with (this) and must return a promise.\n */\n\n\nexport class Router extends View {\n  init() {\n    let {routes, resources} = this.props\n    this._routes = routes.map(config => new Route(config))\n    this._resources = {}\n    if (resources) {\n      for (let [name, func] of Object.entries(resources)) {\n        this._resources[name] = {\n          loaded: false,\n          func: func\n        }\n      }\n    }\n    window.addEventListener('hashchange', e => this._hashChanged())\n    window.addEventListener('load', e => this._hashChanged())\n  }\n  /* \n   */\n  _resolveResources(resources) {\n    let promises = []\n    if (resources) {\n      resources.forEach(name => {\n        let resource = this._resources[name]\n        if (!resource.loaded) {\n          promises.push(resource.func(this))\n        }\n      })\n    }\n    return Promise.all(promises)\n  }\n  _hashChanged() {\n    let url = location.hash.slice(1) || '/';\n    this._matchRoute(url);\n  }\n  /*\n   * Tries to find a view based on url, and will build it\n   */\n  _matchRoute(url) {\n    let len = this._routes.length, matched=false;\n    for (let i=0; i<len; i++) {\n      let route = this._routes[i];\n      let routeData = route.match(url)\n      if (routeData) {\n        matched = true\n        this._resolveResources(route.resources).then(_ => {\n          route.getView(routeData).then(view => {\n            this.root.child(view.root)\n            // Use this? bubble?\n            // call back?\n            //this.app.emit('route_changed', {routeData, url, view})\n          })\n        })\n        break\n      }\n    }\n    if (!matched) {\n      throw new Error('Route not matched: ' + url)\n    }\n  }\n}\n\n/*\n * A route.\n * The path is used for matching and extracting args & params.\n * The path is made of chunks separated by \"/\" e.g. /todos/detail/{id}\n * Chunks are strings or argument descriptors\n * A url matches a route if all the string chunks match e.g.\n * Route path: /todos/detail/{id}\n * Urls:\n *   /todos/detail/001           (yes)\n *   /todos/detail/001?name=joe  (yes, as everything after ? are params)\n *   /todos/001/detail           (no, as chunk[1] != 'detail')\n *   /todos/detail/001/next      (no, as it has more chunks than expected)\n * \n * Config example: \n * {\n *   path: '/todos',\n *   resources: ['todos', 'settings'],\n *   cls: TodoView,\n *   keyFn: foo,            # optional used as cache arg for view\n *   resolve: foo,          # optional used to create data for view\n * }\n * \n * The path may specify params after ? (but all params are passed to the view anyway)\n *  /todos/detail?id,date\n * \n * Args and params may specify a type, in which case they are converted.\n * resolve gets called with (routeData, [this router]) and must return a promise, the return\n * value is passed as data to the view. routeData is {args, params, url}\n */\nexport class Route {\n  constructor(config) {\n    this.resources = config.resources\n    let paramStr, path = config.path;\n    this._vc = new ViewCache(config.cls, this, config.keyFn || defaultKeyFn);\n    [path, paramStr] = path.split('?')\n    this.chunks = this.buildChunks(path) // An array of string or RouteArg\n    this.params = this.buildParams(paramStr)\n    this.resolve = config.resolve || this.defautResolve\n  }\n  defautResolve(routeData) {\n    return Promise.resolve(routeData)\n  }\n  buildChunks(path) {\n    return path.split('/').map(s => {\n      if (s.startsWith('{')) {\n        return new RouteArg(s.slice(1,-1))\n      }\n      return s\n    })\n  }\n  buildParams(paramStr) {\n    let params = {}\n    if (paramStr) {\n      paramStr.split(',').forEach(s => {\n        let r = new RouteArg(s.trim());\n        params[r.name] = r;\n      })\n    }\n    return params\n  }\n  getView(routeData) {\n    return this.resolve(routeData, this).then(result => {return this._vc.get(result)})\n  }\n  match(url) {\n    let front, paramStr, definedChunkCount = this.chunks.length, args = {};\n    [front, ...paramStr] = url.split('?')\n    let foundChunks = front.split('/')\n    if (definedChunkCount !== foundChunks.length) {\n      return false\n    }\n    // determine if non interpreted chunks match.\n    for (let i=0; i<definedChunkCount; i++) {\n      let definedChunk = this.chunks[i]\n      let foundChunk = foundChunks[i]\n      if (definedChunk instanceof RouteArg) {\n        args[definedChunk.name] = _ => definedChunk.convert(foundChunk)\n      } else if (isStr(definedChunk) && definedChunk != foundChunk) {\n        return false\n      }\n    }\n    // If we reach here, url matches, so process args and params\n    for (let a in args) {\n      args[a] = args[a]()\n    }\n    // paramStr had to be an array in case multiple \"?\" in url\n    let params = {}\n    if (paramStr) {\n      paramStr.join('').split('&').forEach(e => {\n        let k, v;\n        [k,v] = e.split('=')\n        if (this.params.hasOwnProperty(k)) {\n          params[k] = this.params[k].convert(v)\n        } else {\n          params[k] = v\n        }\n      })\n    }\n    return {args, params, url}\n  }\n}\n\nexport class RouteArg {\n  constructor(str) {\n    // No error checks :-(\n    let name, conv;\n    [name, conv] = str.split(':')\n    this.name = name\n    switch (conv) {\n      case 'int':\n        this.conv = v => parseInt(v);\n        break;\n      case 'float':\n        this.conv = v => parseFloat(v);\n        break;\n      default:\n        this.conv = v => v;\n    }\n  }\n  convert(val) {\n    return this.conv(val)\n  }\n}\n","import {View} from './view'\nimport {h, mount, ViewCache, wrap} from './utils'\nimport {Router} from './router'\nimport {Store} from './store'\n\nmodule.exports = {mount, h, Router ,Store, View, ViewCache, wrap}","\nexport class Store {\n  constructor(items) {\n    this.nextId = 1\n    this.change = 0\n    this.items = []\n    this.hash = {}\n    this.load(items)\n  }\n  add(item) {\n    this.change\n    return Promise.resolve(this._add(item))\n  }\n  _add(item) {\n    item.id = this.nextId\n    this.nextId ++\n    this.items.push(item)\n    this.hash[item.id] = item\n    return item\n  }\n  update(id, item) {\n    let target = this.hash[id]\n    Object.assign(target, item, {id: id})\n    this.change\n    return Promise.resolve(target)\n  }\n  get(id) {\n    return this.hash[id]\n  }\n  getItems() {\n    return this.items\n  }\n  delete(id) {  \n    this.items = this.items.filter(item => item.id !== id)\n    delete this.hash[id]\n    this.change\n    return Promise.resolve(id)\n  }\n  load(items) {\n    items.forEach(item => this._add(item))\n  }\n}\n"],"names":["doc","document","und","x","undefined","isStr","wrap","html","throwAway","createElement","innerHTML","Wrapper","content","firstChild","createView","cls","props","parent","seq","view","__bv","init","update","ViewCache","keyFn","this","cache","_seq","reset","get","key","hasOwnProperty","element","e","_c","_n","append","item","_append","appendChild","child","clear","replace","el","parentNode","replaceChild","length","textContent","value","inner","items","Array","isArray","_prepRepeat","i","il","_done","_nest","root","__nv","push","visible","use","watch","desc","callback","path","func","chunks","split","n","o","_this","method","css","style","className","cssAdd","classList","add","cssAddTrans","transition","_","_this2","cssRemove","remove","cssRemoveTrans","_this3","cssToggle","toggle","att","name","setAttribute","atts","checked","href","id","src","text","on","event","addEventListener","_this4","fn","Promise","resolve","_this5","transitionEnded","removeEventListener","View","__html__","s","__ov","dom","__uw","__un","debug","c","log","toString","lines","Object","entries","__wc","callbacks","forEach","join","nest","emit","args","target","handlers","_handlers_","apply","old","__gw","reduce","accumulator","index","childNodes","__ia","newValue","previousValue","__wq","__rn","defaultKeyFn","Router","resources","_routes","routes","map","config","Route","_resources","loaded","window","_hashChanged","_resolveResources","promises","resource","all","url","location","hash","slice","_matchRoute","len","matched","route","routeData","match","then","getView","Error","paramStr","_vc","buildChunks","params","buildParams","defautResolve","startsWith","RouteArg","r","trim","result","front","definedChunkCount","foundChunks","definedChunk","foundChunk","convert","a","k","v","str","conv","parseInt","parseFloat","val","module","exports","mount","elementOrId","getElementById","h","tag","Store","nextId","change","load","_add","assign","getItems","filter"],"mappings":"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"}